## Compiler

This generates new docker binaries and weave images from the merge of all the latest code:

```
$ make -C compiler
```

## Amibuilder

This uses vagrant-aws to install dependencies and inject the binaries created by the compiler.  It then creates a new AMI from the instance.

First - [install and configure](amibuilder)

```
$ make -C amibuilder
```

Then - you copy the AMI id generated by the Amibuilder and update the `runnerami` field in the `.aws_secrets` file with this value - this controls which AMI the runner nodes will use.

## Runner

This uses vagrant-aws to spin up 3 nodes for the actual demo - one of the 3 nodes is designated `master` (i.e. it runs the Flocker control service)

```
$ make -C runner
```

## Vagrant builder

Create a Vagrant.box file ready for the Vagrant runner - it will spit out a `vagrantbuilder/vagrantXXX.box` file:

```
$ make -C vagrantbuilder
```

## Vagrant runner

Set up a local testing environment with ZFS on Vagrant.

```
$ make -C vagrantrunner
```
